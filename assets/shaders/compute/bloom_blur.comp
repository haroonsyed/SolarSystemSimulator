#version 430 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std140, binding = 1) buffer screenData {

  float luminance;
  uint width;
  uint height;
  uint percentRangeFromCenterForLuminanceCalc;
  uint isXPass;

};
layout (rgba32f, binding = 3) uniform image2D blurBuffer;

void main() {

  ivec2 pixelPosition = ivec2(gl_GlobalInvocationID.xy);

  // B in the blurBuffer
  int blurSize = 5;

  // We use the sign of luminance to determine if we should do a ypass or xpass (less variables in screenData ssbo)

  vec4 tempColor = vec4(0,0,0,0);
  bool validPixel = false;

  if(isXPass == 1 && pixelPosition.y < height) {
    for(int j=1; j<=blurSize; j++) {
      tempColor += pixelPosition.x + j < width ?  imageLoad(blurBuffer, pixelPosition + ivec2(j, 0)) : vec4(0);
      tempColor += pixelPosition.x - j > 0     ?  imageLoad(blurBuffer, pixelPosition - ivec2(j, 0)) : vec4(0);
    }
    validPixel = true;
  }
  else if(pixelPosition.x < width){
    for(int j=1; j<=blurSize; j++) {
      tempColor += pixelPosition.y + j < height ?  imageLoad(blurBuffer, pixelPosition + ivec2(0, j)) : vec4(0);
      tempColor += pixelPosition.y - j > 0      ?  imageLoad(blurBuffer, pixelPosition - ivec2(0, j)) : vec4(0);
    }
    validPixel = true;
  }

  tempColor /= 2 * blurSize;

  // Write color to hdr buffer
  if(validPixel) {
    imageStore(blurBuffer, pixelPosition, tempColor );
  }

}


