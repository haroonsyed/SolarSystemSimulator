#version 430 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std140, binding = 1) buffer screenData {

  float luminance;
  uint width;
  uint height;
  uint percentRangeFromCenterForLuminanceCalc;
  uint blurPassCount;

};
layout (rgba16f, binding = 2) uniform image2D inputBlurBuffer;
layout (rgba16f, binding = 3) uniform image2D outputBlurBuffer;

void main() {


  uint mipMapLevel = 1 + (blurPassCount / 2);
  uint out_img_width = width >> mipMapLevel;
  uint out_img_height = height >> mipMapLevel;

  ivec2 pixelPosition = ivec2(gl_GlobalInvocationID.xy);

  // Downsample from input when blurring.
  // If mipMapLevel==1 then we don't need to downsample (done already in luminancePass)
  ivec2 samplePixelPosition = mipMapLevel != 1 ? 2 * pixelPosition : pixelPosition; 

  if(pixelPosition.x < out_img_width && pixelPosition.y < out_img_height) {

    // B in the blurBuffer
    int blurSize = 5;

    vec4 tempColor = vec4(0,0,0,0);
    bool isXPass = blurPassCount % 2 == 1;

    if(isXPass) {
      for(int j=1; j<=blurSize; j++) {
        tempColor += imageLoad(inputBlurBuffer, samplePixelPosition + ivec2(j, 0));
        tempColor += imageLoad(inputBlurBuffer, samplePixelPosition - ivec2(j, 0));
      }
    }
    else{
      for(int j=1; j<=blurSize; j++) {
        tempColor += imageLoad(inputBlurBuffer, samplePixelPosition + ivec2(0, j)) ;
        tempColor +=  imageLoad(inputBlurBuffer, samplePixelPosition - ivec2(0, j)) ;
      }
    }

    tempColor /= 2 * blurSize;

    imageStore(outputBlurBuffer, pixelPosition, tempColor);

  }


}


